// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
import { nullTranslator } from '@jupyterlab/translation';
/**
 * Completion provider that uses debugger evaluation for suggestions.
 */
export class DebuggerCompletionProvider {
    constructor(options) {
        this.options = options;
        this.identifier = 'DebuggerCompletionProvider';
        this.rank = 1000;
        const translator = options.translator || nullTranslator;
        this._trans = translator.load('jupyterlab');
        this.name = this._trans.__('Debugger');
        this._debuggerService = options.debuggerService;
    }
    /**
     * Check if this completion provider is applicable to the given context.
     */
    async isApplicable(context) {
        var _a, _b, _c;
        try {
            const spec = await ((_c = (_b = (_a = this._debuggerService.session) === null || _a === void 0 ? void 0 : _a.connection) === null || _b === void 0 ? void 0 : _b.kernel) === null || _c === void 0 ? void 0 : _c.spec);
            return (spec === null || spec === void 0 ? void 0 : spec.language) === 'python';
        }
        catch (error) {
            return false;
        }
    }
    /**
     * Fetch completion suggestions using debugger evaluation.
     */
    async fetch(request, context, trigger) {
        var _a, _b;
        let items = [];
        let parsedResult;
        try {
            const { text, offset } = request;
            const pyCode = `
from IPython.core.completer import provisionalcompleter as _provisionalcompleter
from IPython.core.completer import rectify_completions as _rectify_completions
from IPython.core.completer import IPCompleter
_EXPERIMENTAL_KEY_NAME = "_jupyter_types_experimental"

def getCompletionsForDebugger(code, cursor_pos):
    ip = get_ipython()

    # Access the current debugger frame
    import inspect
    current_frame = inspect.currentframe()

    # Get the frame that called this function (the debugger's target frame)
    caller_frame = current_frame.f_back if current_frame else None

    # Get the debugger's frame variables
    if caller_frame:
        frame_locals = caller_frame.f_locals
        frame_globals = caller_frame.f_globals
    else:
        frame_locals = locals()
        frame_globals = globals()

    local_completer = IPCompleter(shell=ip, namespace=frame_locals, global_namespace=frame_globals, parent=ip)

    with _provisionalcompleter():
        raw_completions = local_completer.completions(code, cursor_pos)
        completions = list(_rectify_completions(code, raw_completions))

        comps = []
        for comp in completions:
            comps.append(
                dict(
                    start=comp.start,
                    end=comp.end,
                    text=comp.text,
                    type=comp.type,
                    signature=comp.signature,
                )
            )

        if completions:
            s = completions[0].start
            e = completions[0].end
            matches = [c.text for c in completions]
            types = [c.type for c in completions]
        else:
            s = cursor_pos
            e = cursor_pos
            matches = []
            types = []

        result = {
            "matches": matches,
            "types": types,
            "cursor_end": e,
            "cursor_start": s,
            "status": "ok",
        }

        return result
`;
            // create method
            await this._debuggerService.evaluate(pyCode);
            const debuggerCompletions = `getCompletionsForDebugger(${JSON.stringify(text)}, ${offset})`;
            const evalReply = await this._debuggerService.evaluate(debuggerCompletions);
            if (!evalReply) {
                return { start: 0, end: 0, items: [] };
            }
            const matches = evalReply.result;
            // Replace single quotes with double quotes in matches string for JSON parsing
            let correctedMatches = matches.replace(/'/g, '"');
            // TODO - Investigate truncation
            // The eval reply from kernel truncates the result string (a string representation
            // of an array containing completion results). Anything after a certain number of
            // matches (19 for ipykernel) is replaced by ellipses, which needs to be removed to parse into JSON.
            correctedMatches = correctedMatches.replace(/, \.\.\./g, '');
            try {
                parsedResult = JSON.parse(correctedMatches);
            }
            catch (error) {
                console.error('Failed to parse corrected matches:', error);
                return { start: 0, end: 0, items: [] };
            }
            // Parse completions into completion items
            const parsedCompletions = parsedResult.matches.map((match, index) => {
                var _a;
                return ({
                    label: match,
                    insertText: match,
                    type: ((_a = parsedResult.types) === null || _a === void 0 ? void 0 : _a[index]) || undefined
                });
            });
            items = [...parsedCompletions];
        }
        catch (error) {
            console.warn('Error fetching debugger completions:', error);
            // Return empty items on error
            return { start: 0, end: 0, items: [] };
        }
        // Extract cursor positions from the parsed result if available
        const start = (_a = parsedResult.cursor_start) !== null && _a !== void 0 ? _a : 0;
        const end = (_b = parsedResult.cursor_end) !== null && _b !== void 0 ? _b : 0;
        return { start, end, items };
    }
}
//# sourceMappingURL=debugger-completion-provider.js.map