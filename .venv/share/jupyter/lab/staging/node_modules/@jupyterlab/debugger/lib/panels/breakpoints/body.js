// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
import { ReactWidget } from '@jupyterlab/ui-components';
import React, { useEffect, useState } from 'react';
import { nullTranslator } from '@jupyterlab/translation';
import { breakpointIcon, selectedBreakpointIcon } from '@jupyterlab/ui-components';
/**
 * The body for a Breakpoints Panel.
 */
export class BreakpointsBody extends ReactWidget {
    /**
     * Instantiate a new Body for the Breakpoints Panel.
     *
     * @param model The model for the breakpoints.
     */
    constructor(model, translator = nullTranslator) {
        super();
        this._model = model;
        this._translator = translator;
        this.addClass('jp-DebuggerBreakpoints-body');
    }
    render() {
        return (React.createElement(BreakpointsComponent, { model: this._model, translator: this._translator }));
    }
}
/**
 * A React component to display a list of breakpoints.
 *
 * @param {object} props The component props.
 * @param props.model The model for the breakpoints.
 * @returns A JSX element.
 */
const BreakpointsComponent = ({ model, translator }) => {
    const trans = translator.load('jupyterlab');
    const [breakpoints, setBreakpoints] = useState(Array.from(model.breakpoints.entries()));
    const [selectedBreakpoint, setSelectedBreakpoint] = useState(null);
    useEffect(() => {
        const updateBreakpoints = (_, updates) => {
            setBreakpoints(Array.from(model.breakpoints.entries()));
        };
        const restoreBreakpoints = (_) => {
            setBreakpoints(Array.from(model.breakpoints.entries()));
        };
        const handleClick = (_, breakpoint) => {
            model.selectedBreakpoint = breakpoint;
        };
        const handleSelectedChanged = (_) => {
            setSelectedBreakpoint(model.selectedBreakpoint);
        };
        model.changed.connect(updateBreakpoints);
        model.restored.connect(restoreBreakpoints);
        model.clicked.connect(handleClick);
        model.selectedChanged.connect(handleSelectedChanged);
        return () => {
            model.changed.disconnect(updateBreakpoints);
            model.restored.disconnect(restoreBreakpoints);
            model.clicked.disconnect(handleClick);
            model.selectedChanged.disconnect(() => handleSelectedChanged);
        };
    });
    return (React.createElement(React.Fragment, null, breakpoints.map(entry => (React.createElement(BreakpointCellComponent, { key: entry[0], breakpoints: entry[1], model: model, selectedBreakpoint: selectedBreakpoint, trans: trans })))));
};
/**
 * A React Component to display breakpoints grouped by source file.
 *
 * @param {object} props The component props.
 * @param props.breakpoints The list of breakpoints.
 * @param props.model The model for the breakpoints.
 * @returns A JSX element.
 */
const BreakpointCellComponent = ({ breakpoints, model, selectedBreakpoint, trans }) => {
    return (React.createElement(React.Fragment, null, breakpoints
        .sort((a, b) => {
        var _a, _b;
        return ((_a = a.line) !== null && _a !== void 0 ? _a : 0) - ((_b = b.line) !== null && _b !== void 0 ? _b : 0);
    })
        .map((breakpoint, index) => {
        var _a, _b, _c, _d;
        return (React.createElement(BreakpointComponent, { key: ((_b = (_a = breakpoint.source) === null || _a === void 0 ? void 0 : _a.path) !== null && _b !== void 0 ? _b : '') + index, breakpoint: breakpoint, model: model, isSelected: (selectedBreakpoint === null || selectedBreakpoint === void 0 ? void 0 : selectedBreakpoint.line) === breakpoint.line &&
                ((_c = selectedBreakpoint === null || selectedBreakpoint === void 0 ? void 0 : selectedBreakpoint.source) === null || _c === void 0 ? void 0 : _c.path) === ((_d = breakpoint.source) === null || _d === void 0 ? void 0 : _d.path), trans: trans }));
    })));
};
/**
 * A React Component to display a single breakpoint.
 *
 * @param {object} props The component props.
 * @param props.breakpoint The breakpoint.
 * @param props.model The model for the breakpoints.
 * @returns A JSX element.
 */
const BreakpointComponent = ({ breakpoint, model, isSelected, trans }) => {
    var _a;
    const display = model.getDisplayName(breakpoint);
    return (React.createElement("div", { className: "jp-DebuggerBreakpoint", onClick: () => model.clicked.emit(breakpoint), title: (_a = breakpoint.source) === null || _a === void 0 ? void 0 : _a.path },
        React.createElement("span", { className: "jp-DebuggerBreakpoint-container" }, !isSelected ? (React.createElement(breakpointIcon.react, { "aria-label": trans.__('Breakpoint') })) : (React.createElement(selectedBreakpointIcon.react, { "aria-label": trans.__('Selected breakpoint') }))),
        React.createElement("span", { className: 'jp-DebuggerBreakpoint-source jp-left-truncated' }, display),
        React.createElement("span", { className: "jp-DebuggerBreakpoint-line" }, breakpoint.line)));
};
//# sourceMappingURL=body.js.map