{
  "version": 3,
  "sources": ["../../../src/render.ts", "../../../src/find-common-ancestor.ts"],
  "sourcesContent": ["import { curveLinear } from 'd3';\nimport ELK from 'elkjs/lib/elk.bundled.js';\nimport type { InternalHelpers, LayoutData, RenderOptions, SVG, SVGGroup } from 'mermaid';\nimport { type TreeData, findCommonAncestor } from './find-common-ancestor.js';\n\ntype Node = LayoutData['nodes'][number];\n// Used to calculate distances in order to avoid floating number rounding issues when comparing floating numbers\nconst epsilon = 0.0001;\ninterface LabelData {\n  width: number;\n  height: number;\n  wrappingWidth?: number;\n  labelNode?: SVGGElement | null;\n}\n\ninterface NodeWithVertex extends Omit<Node, 'domId'> {\n  children?: LayoutData['nodes'];\n  labelData?: LabelData;\n  domId?: Node['domId'] | SVGGroup | d3.Selection<SVGAElement, unknown, Element | null, unknown>;\n}\ninterface Point {\n  x: number;\n  y: number;\n}\nfunction distance(p1?: Point, p2?: Point): number {\n  if (!p1 || !p2) {\n    return 0;\n  }\n  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));\n}\nexport const render = async (\n  data4Layout: LayoutData,\n  svg: SVG,\n  {\n    common,\n    getConfig,\n    insertCluster,\n    insertEdge,\n    insertEdgeLabel,\n    insertMarkers,\n    insertNode,\n    interpolateToCurve,\n    labelHelper,\n    log,\n    positionEdgeLabel,\n  }: InternalHelpers,\n  { algorithm }: RenderOptions\n) => {\n  const nodeDb: Record<string, any> = {};\n  const clusterDb: Record<string, any> = {};\n\n  const addVertex = async (\n    nodeEl: SVGGroup,\n    graph: { children: NodeWithVertex[] },\n    nodeArr: Node[],\n    node: Node\n  ) => {\n    const labelData: LabelData = { width: 0, height: 0 };\n\n    const config = getConfig();\n\n    // Add the element to the DOM\n    if (!node.isGroup) {\n      // Create a clean node object for ELK with only the properties it expects\n      const child: NodeWithVertex = {\n        id: node.id,\n        width: node.width,\n        height: node.height,\n        // Store the original node data for later use\n        label: node.label,\n        isGroup: node.isGroup,\n        shape: node.shape,\n        padding: node.padding,\n        cssClasses: node.cssClasses,\n        cssStyles: node.cssStyles,\n        look: node.look,\n        // Include parentId for subgraph processing\n        parentId: node.parentId,\n      };\n      graph.children.push(child);\n      nodeDb[node.id] = child;\n\n      const childNodeEl = await insertNode(nodeEl, node, { config, dir: node.dir });\n      const boundingBox = childNodeEl.node()!.getBBox();\n      // Store the domId separately for rendering, not in the ELK graph\n      child.domId = childNodeEl;\n      child.calcIntersect = node.calcIntersect;\n      child.width = boundingBox.width;\n      child.height = boundingBox.height;\n    } else {\n      // A subgraph\n      const child: NodeWithVertex & { children: NodeWithVertex[] } = {\n        ...node,\n        children: [],\n      };\n      graph.children.push(child);\n      nodeDb[node.id] = child;\n      await addVertices(nodeEl, nodeArr, child, node.id);\n\n      if (node.label) {\n        // @ts-ignore TODO: fix this\n        const { shapeSvg, bbox } = await labelHelper(nodeEl, node, undefined, true);\n        labelData.width = bbox.width;\n        labelData.wrappingWidth = config.flowchart!.wrappingWidth;\n        // Give some padding for elk\n        labelData.height = bbox.height - 2;\n        labelData.labelNode = shapeSvg.node();\n        // We need the label hight to be able to size the subgraph;\n        shapeSvg.remove();\n      } else {\n        // Subgraph without label\n        labelData.width = 0;\n        labelData.height = 0;\n      }\n      child.labelData = labelData;\n      child.domId = nodeEl;\n    }\n  };\n\n  const addVertices = async function (\n    nodeEl: SVGGroup,\n    nodeArr: Node[],\n    graph: { children: NodeWithVertex[] },\n    parentId?: string\n  ) {\n    const siblings = nodeArr.filter((node) => node?.parentId === parentId);\n    log.info('addVertices APA12', siblings, parentId);\n    // Iterate through each item in the vertex object (containing all the vertices found) in the graph definition\n    await Promise.all(\n      siblings.map(async (node) => {\n        await addVertex(nodeEl, graph, nodeArr, node);\n      })\n    );\n    return graph;\n  };\n\n  const drawNodes = async (\n    relX: number,\n    relY: number,\n    nodeArray: any[],\n    svg: any,\n    subgraphsEl: SVGGroup,\n    depth: number\n  ) => {\n    await Promise.all(\n      nodeArray.map(async function (node: {\n        id: string | number;\n        x: any;\n        y: any;\n        width: number;\n        labels: { width: any }[];\n        height: number;\n        isGroup: any;\n        labelData: any;\n        offset: { posX: number; posY: number };\n        shape: any;\n        domId: { node: () => any; attr: (arg0: string, arg1: string) => void };\n      }) {\n        if (node) {\n          nodeDb[node.id] = node;\n          nodeDb[node.id].offset = {\n            posX: node.x + relX,\n            posY: node.y + relY,\n            x: relX,\n            y: relY,\n            depth,\n            width: Math.max(node.width, node.labels ? node.labels[0]?.width || 0 : 0),\n            height: node.height,\n          };\n          if (node.isGroup) {\n            log.debug('id abc88 subgraph = ', node.id, node.x, node.y, node.labelData);\n            const subgraphEl = subgraphsEl.insert('g').attr('class', 'subgraph');\n            // TODO use faster way of cloning\n            const clusterNode = JSON.parse(JSON.stringify(node));\n            clusterNode.x = node.offset.posX + node.width / 2;\n            clusterNode.y = node.offset.posY + node.height / 2;\n            clusterNode.width = Math.max(clusterNode.width, node.labelData.width);\n            await insertCluster(subgraphEl, clusterNode);\n\n            log.debug('id (UIO)= ', node.id, node.width, node.shape, node.labels);\n          } else {\n            log.info(\n              'id NODE = ',\n              node.id,\n              node.x,\n              node.y,\n              relX,\n              relY,\n              node.domId.node(),\n              `translate(${node.x + relX + node.width / 2}, ${node.y + relY + node.height / 2})`\n            );\n            node.domId.attr(\n              'transform',\n              `translate(${node.x + relX + node.width / 2}, ${node.y + relY + node.height / 2})`\n            );\n          }\n        }\n      })\n    );\n\n    await Promise.all(\n      nodeArray.map(async function (node: { isGroup: any; x: any; y: any; children: any }) {\n        if (node?.isGroup) {\n          await drawNodes(relX + node.x, relY + node.y, node.children, svg, subgraphsEl, depth + 1);\n        }\n      })\n    );\n  };\n\n  const addSubGraphs = (nodeArr: any[]): TreeData => {\n    const parentLookupDb: TreeData = { parentById: {}, childrenById: {} };\n    const subgraphs = nodeArr.filter((node: { isGroup: any }) => node.isGroup);\n    log.info('Subgraphs - ', subgraphs);\n    subgraphs.forEach((subgraph: { id: string }) => {\n      const children = nodeArr.filter((node: { parentId: any }) => node.parentId === subgraph.id);\n      children.forEach((node: any) => {\n        parentLookupDb.parentById[node.id] = subgraph.id;\n        if (parentLookupDb.childrenById[subgraph.id] === undefined) {\n          parentLookupDb.childrenById[subgraph.id] = [];\n        }\n        parentLookupDb.childrenById[subgraph.id].push(node);\n      });\n    });\n\n    subgraphs.forEach(function (subgraph: { id: string | number }) {\n      const data: any = { id: subgraph.id };\n      if (parentLookupDb.parentById[subgraph.id] !== undefined) {\n        data.parent = parentLookupDb.parentById[subgraph.id];\n      }\n    });\n    return parentLookupDb;\n  };\n\n  const getEdgeStartEndPoint = (edge: any) => {\n    const source: any = edge.start;\n    const target: any = edge.end;\n\n    // Save the original source and target\n    const sourceId = source;\n    const targetId = target;\n\n    const startNode = nodeDb[edge.start.id];\n    const endNode = nodeDb[edge.end.id];\n\n    if (!startNode || !endNode) {\n      return { source, target };\n    }\n\n    // Add the edge to the graph\n    return { source, target, sourceId, targetId };\n  };\n\n  const calcOffset = function (src: string, dest: string, parentLookupDb: TreeData) {\n    const ancestor = findCommonAncestor(src, dest, parentLookupDb);\n    if (ancestor === undefined || ancestor === 'root') {\n      return { x: 0, y: 0 };\n    }\n\n    const ancestorOffset = nodeDb[ancestor].offset;\n    return { x: ancestorOffset.posX, y: ancestorOffset.posY };\n  };\n\n  /**\n   * Add edges to graph based on parsed graph definition\n   */\n  const addEdges = async function (\n    dataForLayout: { edges: any; direction?: string },\n    graph: {\n      id?: string;\n      layoutOptions?: {\n        'elk.hierarchyHandling': string;\n        'elk.algorithm': any;\n        'nodePlacement.strategy': any;\n        'elk.layered.mergeEdges': any;\n        'elk.direction': string;\n        'spacing.baseValue': number;\n      };\n      children?: never[];\n      edges: any;\n    },\n    svg: SVG\n  ) {\n    log.info('abc78 DAGA edges = ', dataForLayout);\n    const edges = dataForLayout.edges;\n    const labelsEl = svg.insert('g').attr('class', 'edgeLabels');\n    const linkIdCnt: any = {};\n    const dir = dataForLayout.direction || 'DOWN';\n    let defaultStyle: string | undefined;\n    let defaultLabelStyle: string | undefined;\n\n    await Promise.all(\n      edges.map(async function (edge: {\n        id: string;\n        start: string;\n        end: string;\n        length: number;\n        text: undefined;\n        label: any;\n        type: string;\n        stroke: any;\n        interpolate: undefined;\n        style: undefined;\n        labelType: any;\n        startLabelRight?: string;\n        endLabelLeft?: string;\n      }) {\n        // Identify Link\n        const linkIdBase = edge.id; // 'L-' + edge.start + '-' + edge.end;\n        // count the links from+to the same node to give unique id\n        if (linkIdCnt[linkIdBase] === undefined) {\n          linkIdCnt[linkIdBase] = 0;\n          log.info('abc78 new entry', linkIdBase, linkIdCnt[linkIdBase]);\n        } else {\n          linkIdCnt[linkIdBase]++;\n          log.info('abc78 new entry', linkIdBase, linkIdCnt[linkIdBase]);\n        }\n        const linkId = linkIdBase + '_' + linkIdCnt[linkIdBase];\n        edge.id = linkId;\n        log.info('abc78 new link id to be used is', linkIdBase, linkId, linkIdCnt[linkIdBase]);\n        const linkNameStart = 'LS_' + edge.start;\n        const linkNameEnd = 'LE_' + edge.end;\n\n        const edgeData: any = { style: '', labelStyle: '' };\n        edgeData.minlen = edge.length || 1;\n        edge.text = edge.label;\n        // Set link type for rendering\n        if (edge.type === 'arrow_open') {\n          edgeData.arrowhead = 'none';\n        } else {\n          edgeData.arrowhead = 'normal';\n        }\n\n        // Check of arrow types, placed here in order not to break old rendering\n        edgeData.arrowTypeStart = 'arrow_open';\n        edgeData.arrowTypeEnd = 'arrow_open';\n\n        /* eslint-disable no-fallthrough */\n        switch (edge.type) {\n          case 'double_arrow_cross':\n            edgeData.arrowTypeStart = 'arrow_cross';\n          case 'arrow_cross':\n            edgeData.arrowTypeEnd = 'arrow_cross';\n            break;\n          case 'double_arrow_point':\n            edgeData.arrowTypeStart = 'arrow_point';\n          case 'arrow_point':\n            edgeData.arrowTypeEnd = 'arrow_point';\n            break;\n          case 'double_arrow_circle':\n            edgeData.arrowTypeStart = 'arrow_circle';\n          case 'arrow_circle':\n            edgeData.arrowTypeEnd = 'arrow_circle';\n            break;\n        }\n\n        let style = '';\n        let labelStyle = '';\n\n        edgeData.startLabelRight = edge.startLabelRight;\n        edgeData.endLabelLeft = edge.endLabelLeft;\n\n        switch (edge.stroke) {\n          case 'normal':\n            style = 'fill:none;';\n            if (defaultStyle !== undefined) {\n              style = defaultStyle;\n            }\n            if (defaultLabelStyle !== undefined) {\n              labelStyle = defaultLabelStyle;\n            }\n            edgeData.thickness = 'normal';\n            edgeData.pattern = 'solid';\n            break;\n          case 'dotted':\n            edgeData.thickness = 'normal';\n            edgeData.pattern = 'dotted';\n            edgeData.style = 'fill:none;stroke-width:2px;stroke-dasharray:3;';\n            break;\n          case 'thick':\n            edgeData.thickness = 'thick';\n            edgeData.pattern = 'solid';\n            edgeData.style = 'stroke-width: 3.5px;fill:none;';\n            break;\n        }\n\n        edgeData.style = edgeData.style += style;\n        edgeData.labelStyle = edgeData.labelStyle += labelStyle;\n\n        const conf = getConfig();\n        if (edge.interpolate !== undefined) {\n          edgeData.curve = interpolateToCurve(edge.interpolate, curveLinear);\n        } else if (edges.defaultInterpolate !== undefined) {\n          edgeData.curve = interpolateToCurve(edges.defaultInterpolate, curveLinear);\n        } else {\n          // @ts-ignore TODO: fix this\n          edgeData.curve = interpolateToCurve(conf.curve, curveLinear);\n        }\n\n        if (edge.text === undefined) {\n          if (edge.style !== undefined) {\n            edgeData.arrowheadStyle = 'fill: #333';\n          }\n        } else {\n          edgeData.arrowheadStyle = 'fill: #333';\n          edgeData.labelpos = 'c';\n        }\n\n        edgeData.labelType = edge.labelType;\n        edgeData.label = (edge?.text || '').replace(common.lineBreakRegex, '\\n');\n\n        if (edge.style === undefined) {\n          edgeData.style = edgeData.style || 'stroke: #333; stroke-width: 1.5px;fill:none;';\n        }\n\n        edgeData.labelStyle = edgeData.labelStyle.replace('color:', 'fill:');\n\n        edgeData.id = linkId;\n        edgeData.classes = 'flowchart-link ' + linkNameStart + ' ' + linkNameEnd;\n\n        const labelEl = await insertEdgeLabel(labelsEl, edgeData);\n\n        // calculate start and end points of the edge, note that the source and target\n        // can be modified for shapes that have ports\n        // @ts-ignore TODO: fix this\n        const { source, target, sourceId, targetId } = getEdgeStartEndPoint(edge, dir);\n        log.debug('abc78 source and target', source, target);\n        // Add the edge to the graph\n        graph.edges.push({\n          // @ts-ignore TODO: fix this\n          id: 'e' + edge.start + edge.end,\n          ...edge,\n          sources: [source],\n          targets: [target],\n          sourceId,\n          targetId,\n          labelEl: labelEl,\n          labels: [\n            {\n              width: edgeData.width,\n              height: edgeData.height,\n              orgWidth: edgeData.width,\n              orgHeight: edgeData.height,\n              text: edgeData.label,\n              layoutOptions: {\n                'edgeLabels.inline': 'true',\n                'edgeLabels.placement': 'CENTER',\n              },\n            },\n          ],\n          edgeData,\n        });\n      })\n    );\n    return graph;\n  };\n\n  function dir2ElkDirection(dir: any) {\n    switch (dir) {\n      case 'LR':\n        return 'RIGHT';\n      case 'RL':\n        return 'LEFT';\n      case 'TB':\n        return 'DOWN';\n      case 'BT':\n        return 'UP';\n      default:\n        return 'DOWN';\n    }\n  }\n\n  function setIncludeChildrenPolicy(nodeId: string, ancestorId: string) {\n    const node = nodeDb[nodeId];\n\n    if (!node) {\n      return;\n    }\n    if (node?.layoutOptions === undefined) {\n      node.layoutOptions = {};\n    }\n    node.layoutOptions['elk.hierarchyHandling'] = 'INCLUDE_CHILDREN';\n    if (node.id !== ancestorId) {\n      setIncludeChildrenPolicy(node.parentId, ancestorId);\n    }\n  }\n\n  // @ts-ignore - ELK is not typed\n  const elk = new ELK();\n  const element = svg.select('g');\n  // Add the arrowheads to the svg\n  insertMarkers(element, data4Layout.markers, data4Layout.type, data4Layout.diagramId);\n\n  // Setup the graph with the layout options and the data for the layout\n  let elkGraph: any = {\n    id: 'root',\n    layoutOptions: {\n      'elk.hierarchyHandling': 'INCLUDE_CHILDREN',\n      'elk.layered.crossingMinimization.forceNodeModelOrder':\n        data4Layout.config.elk?.forceNodeModelOrder,\n      'elk.layered.considerModelOrder.strategy': data4Layout.config.elk?.considerModelOrder,\n\n      'elk.algorithm': algorithm,\n      'nodePlacement.strategy': data4Layout.config.elk?.nodePlacementStrategy,\n      'elk.layered.mergeEdges': data4Layout.config.elk?.mergeEdges,\n      'elk.direction': 'DOWN',\n      'spacing.baseValue': 35,\n      'elk.layered.unnecessaryBendpoints': true,\n      'elk.layered.cycleBreaking.strategy': data4Layout.config.elk?.cycleBreakingStrategy,\n      // 'spacing.nodeNode': 20,\n      // 'spacing.nodeNodeBetweenLayers': 25,\n      // 'spacing.edgeNode': 20,\n      // 'spacing.edgeNodeBetweenLayers': 10,\n      // 'spacing.edgeEdge': 10,\n      // 'spacing.edgeEdgeBetweenLayers': 20,\n      // 'spacing.nodeSelfLoop': 20,\n      // Tweaking options\n      // 'elk.layered.nodePlacement.favorStraightEdges': true,\n      // 'nodePlacement.feedbackEdges': true,\n      // 'elk.layered.wrapping.multiEdge.improveCuts': true,\n      // 'elk.layered.wrapping.multiEdge.improveWrappedEdges': true,\n      // 'elk.layered.wrapping.strategy': 'MULTI_EDGE',\n      // 'elk.layered.edgeRouting.selfLoopDistribution': 'EQUALLY',\n      // 'elk.layered.mergeHierarchyEdges': true,\n      // 'elk.layered.feedbackEdges': true,\n      // 'elk.layered.crossingMinimization.semiInteractive': true,\n      // 'elk.layered.edgeRouting.splines.sloppy.layerSpacingFactor': 1,\n      // 'elk.layered.edgeRouting.polyline.slopedEdgeZoneWidth': 4.0,\n      // 'elk.layered.wrapping.validify.strategy': 'LOOK_BACK',\n      // 'elk.insideSelfLoops.activate': true,\n      // 'elk.alg.layered.options.EdgeStraighteningStrategy': 'NONE',\n      // 'elk.layered.considerModelOrder.strategy': 'NODES_AND_EDGES', // NODES_AND_EDGES\n      // 'elk.layered.wrapping.cutting.strategy': 'ARD', // NODES_AND_EDGES\n    },\n    children: [],\n    edges: [],\n  };\n\n  log.info('Drawing flowchart using v4 renderer', elk);\n\n  // Set the direction of the graph based on the parsed information\n  const dir = data4Layout.direction || 'DOWN';\n  elkGraph.layoutOptions['elk.direction'] = dir2ElkDirection(dir);\n\n  // Create the lookup db for the subgraphs and their children to used when creating\n  // the tree structured graph\n  const parentLookupDb: any = addSubGraphs(data4Layout.nodes);\n\n  // Add elements in the svg to be used to hold the subgraphs container\n  // elements and the nodes\n  const subGraphsEl = svg.insert('g').attr('class', 'subgraphs');\n\n  const nodeEl = svg.insert('g').attr('class', 'nodes');\n\n  // Add the nodes to the graph, this will entail creating the actual nodes\n  // in order to get the size of the node. You can't get the size of a node\n  // that is not in the dom so we need to add it to the dom, get the size\n  // we will position the nodes when we get the layout from elkjs\n  elkGraph = await addVertices(nodeEl, data4Layout.nodes, elkGraph);\n  // Time for the edges, we start with adding an element in the node to hold the edges\n  const edgesEl = svg.insert('g').attr('class', 'edges edgePaths');\n\n  // Add the edges to the elk graph, this will entail creating the actual edges\n  elkGraph = await addEdges(data4Layout, elkGraph, svg);\n\n  // Iterate through all nodes and add the top level nodes to the graph\n  const nodes = data4Layout.nodes;\n  nodes.forEach((n: { id: string | number }) => {\n    const node = nodeDb[n.id];\n\n    // Subgraph\n    if (parentLookupDb.childrenById[node.id] !== undefined) {\n      node.labels = [\n        {\n          text: node.label,\n          width: node?.labelData?.width || 50,\n          height: node?.labelData?.height || 50,\n        },\n        (node.width = node.width + 2 * node.padding),\n        log.debug('UIO node label', node?.labelData?.width, node.padding),\n      ];\n      node.layoutOptions = {\n        'spacing.baseValue': 30,\n        'nodeLabels.placement': '[H_CENTER V_TOP, INSIDE]',\n      };\n      if (node.dir) {\n        node.layoutOptions = {\n          ...node.layoutOptions,\n          'elk.algorithm': algorithm,\n          'elk.direction': dir2ElkDirection(node.dir),\n          'nodePlacement.strategy': data4Layout.config.elk?.nodePlacementStrategy,\n          'elk.layered.mergeEdges': data4Layout.config.elk?.mergeEdges,\n          'elk.hierarchyHandling': 'SEPARATE_CHILDREN',\n        };\n      }\n      delete node.x;\n      delete node.y;\n      delete node.width;\n      delete node.height;\n    }\n  });\n  log.debug('APA01 processing edges, count:', elkGraph.edges.length);\n  elkGraph.edges.forEach((edge: any, index: number) => {\n    log.debug('APA01 processing edge', index, ':', edge);\n    const source = edge.sources[0];\n    const target = edge.targets[0];\n    log.debug('APA01 source:', source, 'target:', target);\n    log.debug('APA01 nodeDb[source]:', nodeDb[source]);\n    log.debug('APA01 nodeDb[target]:', nodeDb[target]);\n\n    if (nodeDb[source] && nodeDb[target] && nodeDb[source].parentId !== nodeDb[target].parentId) {\n      const ancestorId = findCommonAncestor(source, target, parentLookupDb);\n      // an edge that breaks a subgraph has been identified, set configuration accordingly\n      setIncludeChildrenPolicy(source, ancestorId);\n      setIncludeChildrenPolicy(target, ancestorId);\n    }\n  });\n\n  log.debug('APA01 before');\n  log.debug('APA01 elkGraph structure:', JSON.stringify(elkGraph, null, 2));\n  log.debug('APA01 elkGraph.children length:', elkGraph.children?.length);\n  log.debug('APA01 elkGraph.edges length:', elkGraph.edges?.length);\n\n  // Validate that all edge references exist as nodes\n  elkGraph.edges?.forEach((edge: any, index: number) => {\n    log.debug(`APA01 validating edge ${index}:`, edge);\n    if (edge.sources) {\n      edge.sources.forEach((sourceId: any) => {\n        const sourceExists = elkGraph.children?.some((child: any) => child.id === sourceId);\n        log.debug(`APA01 source ${sourceId} exists:`, sourceExists);\n      });\n    }\n    if (edge.targets) {\n      edge.targets.forEach((targetId: any) => {\n        const targetExists = elkGraph.children?.some((child: any) => child.id === targetId);\n        log.debug(`APA01 target ${targetId} exists:`, targetExists);\n      });\n    }\n  });\n\n  let g;\n  try {\n    g = await elk.layout(elkGraph);\n    log.debug('APA01 after - success');\n    log.debug('APA01 layout result:', JSON.stringify(g, null, 2));\n  } catch (error) {\n    log.error('APA01 ELK layout error:', error);\n    throw error;\n  }\n\n  // debugger;\n  await drawNodes(0, 0, g.children, svg, subGraphsEl, 0);\n  g.edges?.map(\n    (edge: {\n      sources: (string | number)[];\n      targets: (string | number)[];\n      start: any;\n      end: any;\n      sections: { startPoint: any; endPoint: any; bendPoints: any }[];\n      points: any[];\n      x: any;\n      labels: { height: number; width: number; x: number; y: number }[];\n      y: any;\n    }) => {\n      // (elem, edge, clusterDb, diagramType, graph, id)\n      const startNode = nodeDb[edge.sources[0]];\n      const startCluster = parentLookupDb[edge.sources[0]];\n      const endNode = nodeDb[edge.targets[0]];\n      const sourceId = edge.start;\n      const targetId = edge.end;\n\n      const offset = calcOffset(sourceId, targetId, parentLookupDb);\n      log.debug(\n        'APA18 offset',\n        offset,\n        sourceId,\n        ' ==> ',\n        targetId,\n        'edge:',\n        edge,\n        'cluster:',\n        startCluster,\n        startNode\n      );\n      if (edge.sections) {\n        const src = edge.sections[0].startPoint;\n        const dest = edge.sections[0].endPoint;\n        const segments = edge.sections[0].bendPoints ? edge.sections[0].bendPoints : [];\n\n        const segPoints = segments.map((segment: { x: any; y: any }) => {\n          return { x: segment.x + offset.x, y: segment.y + offset.y };\n        });\n        edge.points = [\n          { x: src.x + offset.x, y: src.y + offset.y },\n          ...segPoints,\n          { x: dest.x + offset.x, y: dest.y + offset.y },\n        ];\n\n        let sw = startNode.width;\n        let ew = endNode.width;\n        if (startNode.isGroup) {\n          const bbox = startNode.domId.node().getBBox();\n          // sw = Math.max(bbox.width, startNode.width, startNode.labels[0].width);\n          sw = Math.max(startNode.width, startNode.labels[0].width + startNode.padding);\n          // sw = startNode.width;\n          log.debug(\n            'UIO width',\n            startNode.id,\n            startNode.with,\n            'bbox.width=',\n            bbox.width,\n            'lw=',\n            startNode.labels[0].width,\n            'node:',\n            startNode.width,\n            'SW = ',\n            sw\n            // 'HTML:',\n            // startNode.domId.node().innerHTML\n          );\n        }\n        if (endNode.isGroup) {\n          const bbox = endNode.domId.node().getBBox();\n          ew = Math.max(endNode.width, endNode.labels[0].width + endNode.padding);\n\n          log.debug(\n            'UIO width',\n            startNode.id,\n            startNode.with,\n            bbox.width,\n            'EW = ',\n            ew,\n            'HTML:',\n            startNode.innerHTML\n          );\n        }\n\n        if (startNode.calcIntersect) {\n          const intersection = startNode.calcIntersect(\n            {\n              x: startNode.offset.posX + startNode.width / 2,\n              y: startNode.offset.posY + startNode.height / 2,\n              width: startNode.width,\n              height: startNode.height,\n            },\n            edge.points[0]\n          );\n\n          if (distance(intersection, edge.points[0]) > epsilon) {\n            edge.points.unshift(intersection);\n          }\n        }\n        if (endNode.calcIntersect) {\n          const intersection = endNode.calcIntersect(\n            {\n              x: endNode.offset.posX + endNode.width / 2,\n              y: endNode.offset.posY + endNode.height / 2,\n              width: endNode.width,\n              height: endNode.height,\n            },\n            edge.points[edge.points.length - 1]\n          );\n\n          if (distance(intersection, edge.points[edge.points.length - 1]) > epsilon) {\n            edge.points.push(intersection);\n          }\n        }\n\n        const paths = insertEdge(\n          edgesEl,\n          edge,\n          clusterDb,\n          data4Layout.type,\n          startNode,\n          endNode,\n          data4Layout.diagramId\n        );\n\n        edge.x = edge.labels[0].x + offset.x + edge.labels[0].width / 2;\n        edge.y = edge.labels[0].y + offset.y + edge.labels[0].height / 2;\n        positionEdgeLabel(edge, paths);\n      }\n    }\n  );\n};\n", "export interface TreeData {\n  parentById: Record<string, string>;\n  childrenById: Record<string, string[]>;\n}\n\nexport const findCommonAncestor = (id1: string, id2: string, { parentById }: TreeData) => {\n  const visited = new Set();\n  let currentId = id1;\n\n  // Edge case with self edges\n  if (id1 === id2) {\n    return parentById[id1] || 'root';\n  }\n\n  while (currentId) {\n    visited.add(currentId);\n    if (currentId === id2) {\n      return currentId;\n    }\n    currentId = parentById[currentId];\n  }\n\n  currentId = id2;\n  while (currentId) {\n    if (visited.has(currentId)) {\n      return currentId;\n    }\n    currentId = parentById[currentId];\n  }\n\n  return 'root';\n};\n"],
  "mappings": "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",
  "names": ["nodeEl", "svg", "parentLookupDb", "dir"]
}
